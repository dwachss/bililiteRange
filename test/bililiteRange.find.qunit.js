multitest("Testing bililiteRange find", function (rng, el, text, i, assert){
	if (el.nodeName.toLowerCase() == 'input'){
		// no lines
		text = '2020-07-04';
		var bounds = [5,7];
	}else{
		text = 'one\n007\n\tthree';
		bounds = [5,7];
	}
	rng.all(text).bounds(/07/);
	assert.deepEqual(rng.bounds(), bounds, 'simple RegExp search');
	assert.equal (rng.match[0], '07', 'match recorded');
	if (i === 3) return; // not too much we can do with NothingRange
	
	rng.all('abc def abc def');
	rng.bounds('start').bounds(/def/).bounds(/abc/);
	assert.deepEqual(rng.bounds(), [8,11], 'forward RegExp search');
	rng.bounds('start').bounds(/def/).bounds(/abc/, 'b');
	assert.deepEqual(rng.bounds(), [0,3], 'backward RegExp search');
	rng.bounds('start').bounds(/DEF/i).bounds('find', 'ABC', 'i');
	assert.deepEqual(rng.bounds(), [8,11], 'ignorecase search');
	rng.bounds('start').bounds([8,11]).bounds(/abc/);
	assert.deepEqual(rng.bounds(), [0,3], 'search wraps');
	rng.bounds('start').bounds([8,11]).bounds(/abc/, 'W');
	assert.deepEqual(rng.bounds(), [8,11], 'no wrap search leaves bounds unchanged');
	assert.equal(rng.match, false, 'match is false on failed search');
	
	rng.all('test [a-z]');
	rng.bounds('start').bounds('find', '[a-z]', 'v');
	assert.equal(rng.text(), 't', 'magic option uses special characters');
	rng.bounds('start').bounds('find', '\\[a-z\\]', 'v');
	assert.equal(rng.text(), '[a-z]', 'magic option does not use escaped special characters');
	rng.bounds('start').bounds('find', '[a-z]', 'V');
	assert.equal(rng.text(), '[a-z]', 'nomagic option does not use special characters');
});
multitest("Testing bililiteRange find restricted/sticky bounds", function (rng, el, text, i, assert){
	if (i === 3) return assert.expect(0);
	rng.all('abc def abc def');
	rng.bounds([4,7]).bounds(/def/);
	assert.deepEqual(rng.bounds(), [12,15], 'search forward');
	rng.bounds([4,7]).bounds(/e/, 'r');
	assert.deepEqual(rng.bounds(), [5,6], 'search forward restricted');
	rng.bounds([8,11]).bounds(/def/);
	assert.deepEqual(rng.bounds(), [12,15], 'search forward (again)');
	rng.bounds([8,11]).bounds(/def/, 'b');
	assert.deepEqual(rng.bounds(), [4,7], 'search backward');
	rng.bounds([4,7]).bounds(/e/, 'ry');
	assert.deepEqual(rng.match, false, 'search forward sticky restricted fails');
	rng.bounds([4,7]).bounds(/d/, 'ry');
	assert.deepEqual(rng.bounds(), [4,5], 'search forward sticky restricted');
	rng.bounds([4,7]).bounds(/ef/, 'bry');
	assert.deepEqual(rng.bounds(), [5,7], 'search backward sticky restricted');
	assert.ok(rng.match, 'search backward sticky restricted succeeds');
	rng.bounds([4,7]).bounds(/ abc/y);
	assert.deepEqual(rng.bounds(), [7,11], 'search sticky forward');
	rng.bounds([4,7]).bounds(/def/y);
	assert.deepEqual(rng.match, false, 'search sticky forward fails');
	rng.bounds('end').bounds(/def/y, 'b');
	assert.deepEqual(rng.bounds(), [12,15], 'search sticky backward from end');
	rng.bounds([4,7]).bounds(/c /y, 'b');
	assert.deepEqual(rng.bounds(), [2,4], 'search sticky backward');
});
multitest("Testing bililiteRange find greedy correctness", function (rng, el, text, i, assert){
	if (i === 3) return assert.expect(0);
	rng.all ('aaaaa').bounds(3).bounds(/a+/);
	assert.equal(rng.text(), 'aa', 'greedy bounds found forwards correctly');
	rng.all ('aaaaaa').bounds(3).bounds(/a+/, 'b');
	assert.equal(rng.text(), 'aaa', 'greedy bounds found backward correctly');
});
multitest("Testing bililiteRange from/to/whole paragraphs", function (rng, el, text, i, assert){
	if (i == 2 || i == 3) return assert.expect(0);
	text = '123\n567\n\n012\n\n567';
	rng.all(text);
	rng.bounds('start').bounds('to', 'paragraph');
	assert.deepEqual(rng.bounds(), [0,7],'to paragraph');
	rng.bounds('endbounds').bounds('to', 'paragraph');
	assert.deepEqual(rng.bounds(), [7,7],'at end of paragraph, to paragraph doesn\'t move');
	rng.bounds('from', 'paragraph');
	assert.deepEqual(rng.bounds(), [0,7],'from paragraph');
	rng.bounds(1).bounds('whole', 'paragraph');
	assert.equal(rng.text(), '123\n567', 'whole paragraph');
	rng.bounds('end').bounds('to', 'paragraph');
	assert.deepEqual(rng.bounds(), [17,17],'to paragraph from end');
	rng.bounds('endbounds').bounds('to', 'paragraph');
	assert.deepEqual(rng.bounds(), [17,17],'from end to end');
	rng.bounds('end').bounds('from', 'paragraph');
	assert.deepEqual(rng.bounds(), [14,17],'from paragraph, last paragraph');
	rng.bounds(11).bounds('whole', 'paragraph');
	assert.equal(rng.text(), '012', 'whole paragraph');
	rng.bounds([2,3]).bounds('whole', /1/);
	assert.equal(rng.text(), '23\n567\n\n0', 'whole with arbitrary separator');
});
multitest("Testing bililiteRange from/to/whole paragraph with outer", function (rng, el, text, i, assert){
	if (i == 2 || i == 3) return assert.expect(0);
	text = '123\n567\n\n012\n\n567';
	rng.all(text);
	rng.bounds('start').bounds('to', 'paragraph', true);
	assert.deepEqual(rng.bounds(), [0,9],'to paragraph');
	rng.bounds('endbounds').bounds('to', 'paragraph', true);
	assert.deepEqual(rng.bounds(), [9,14],'after end of paragraph, to paragraph');
	rng.bounds('from', 'paragraph', true);
	assert.deepEqual(rng.bounds(), [7,14],'from paragraph');
	rng.bounds(1).bounds('whole', 'paragraph', true);
	assert.equal(rng.text(), '123\n567\n\n', 'whole paragraph');
	rng.bounds(11).bounds('whole', 'paragraph', true);
	assert.equal(rng.text(), '012\n\n', 'whole paragraph (includes separator after, not before');
	rng.bounds([2,3]).bounds('whole', /1/, true);
	assert.equal(rng.text(), '23\n567\n\n01', 'whole with arbitrary separator');
});
multitest("Testing bililiteRange words and sentences", function (rng, el, text, i, assert){
	if (i == 3) return assert.expect(0);
	text = 'Hello, world. This is a   test';
	rng.all(text);
	rng.bounds(1).bounds('whole', 'word');
	assert.equal(rng.text(), 'Hello', 'whole word');
	rng.bounds('whole', 'sentence');
	assert.equal(rng.text(), 'Hello, world', 'whole sentence');
	rng.bounds(/,/);
	rng.bounds('whole', 'word');
	assert.equal (rng.text(), ', ', 'nonwords are selected with word separator');
	rng.bounds(/This/).bounds('whole', 'word');
	assert.equal(rng.text(), 'This', 'whole word remains whole');
	rng.bounds('whole', 'sentence');
	assert.equal(rng.text(), 'This is a   test', 'whole sentence without period');
	text = 'ב◌ּ◌ְר◌ֵאש◌ׁ◌ִית, ב◌ּ◌ָר◌ָא';
	rng.all(text);
	rng.bounds(1).bounds('whole', 'bigword');
	assert.equal(rng.text(), 'ב◌ּ◌ְר◌ֵאש◌ׁ◌ִית,', 'bigword matches arbitrary unicode');
});
multitest("Testing bililiteRange whole sections", function (rng, el, text, i, assert){
	if (i == 2 || i == 3) return assert.expect(0);
	text = '123\n----\n5678\n<hr/>\n012\n\n567';
	rng.all(text);
	rng.bounds('start').bounds('whole', 'section');
	assert.equal(rng.text(), '123','whole section --- ');
	rng.bounds('end').bounds('whole', 'section');
	assert.equal(rng.text(), '012\n\n567','whole section <hr>');
	rng.bounds('line', 3).bounds('whole', 'section');
	assert.equal(rng.text(), '5678','whole section between --- and <HR> (uppercase works)');
});
multitest("Testing bililiteRange two-sided separators", function (rng, el, text, i, assert){
	if (i == 3) return assert.expect(0);
	rng.all('abc(def)ghi').bounds(5).bounds('whole', '()');
	assert.equal(rng.text(), 'def', 'whole ()');
	rng.all('abc(def)ghi').bounds(5).bounds('whole', '()', true);
	assert.equal(rng.text(), '(def)', 'whole () outer');
	rng.all('abc"def"ghi').bounds(5).bounds('whole', '"');
	assert.equal(rng.text(), 'def', 'whole "');
	rng.all('abc"def"ghi').bounds(5).bounds('whole', '"', true);
	assert.equal(rng.text(), '"def"', 'whole " outer');
});
multitest("Testing bililiteRange replace", function (rng, el, text, i, assert){
	if (i == 3) return assert.expect(0);
	text = 'abcdefabc';
	rng.all (text);
	rng.bounds({source: 'def', flags: ''});
	assert.deepEqual(rng.bounds(), [3,6], 'ducktyped RegExp');
	rng.replace(/e/, '.');
	assert.deepEqual(rng.all(), 'abcd.fabc', 'replace forward with string');
	rng.all (text).bounds({source: 'def', flags: ''});
	rng.replace(/e/y, '.');
	assert.equal(rng.all(), 'abcdefabc', 'replace forward sticky with string, no match');
	rng.all (text).bounds({source: 'def', flags: ''});
	rng.replace(/d/y, '.');
	assert.equal(rng.all(), 'abc.efabc', 'replace forward sticky with string, match');
	rng.all (text).bounds({source: 'def', flags: ''});
	rng.replace(/f/, '.', 'by');
	assert.equal(rng.all(), 'abcde.abc', 'replace backward sticky with string, match');
	rng.all (text).bounds('all');
	rng.replace('[ab]', match => match.toUpperCase(), 'vg');
	assert.equal(rng.all(), 'ABcdefABc', 'replace global with function, flags parameter');
	rng.all (text).bounds('all');
	rng.replace('b', '.', 'b');
	assert.equal(rng.all(), 'abcdefa.c', 'replace backward not global');
});